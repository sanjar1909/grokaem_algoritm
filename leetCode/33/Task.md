# 33. Поиск в повернутом отсортированном массиве

Дан целочисленный массив `nums`, отсортированный в порядке возрастания (с уникальными значениями).

Перед тем как попасть в вашу функцию, массив `nums` **возможно был повернут влево** на неизвестное количество позиций `k` (`1 <= k < nums.length`) так, что итоговый массив имеет вид:

*(индексация с 0)*

Например:  
`[0,1,2,4,5,6,7]` может быть повернут влево на 3 позиции и превратиться в `[4,5,6,7,0,1,2]`.

---

## Задача
Дан массив `nums` после возможного поворота и целое число `target`.  
Верните **индекс** `target`, если он присутствует в `nums`, или `-1`, если его нет.

**Требование по времени:** алгоритм должен работать за `O(log n)`.

---

## Примеры

**Пример 1**  
**Ввод:**   nums = [4,5,6,7,0,1,2], target = 0

**Вывод:**  4


**Пример 2**  
**Ввод:** nums = [4,5,6,7,0,1,2], target = 3
**Вывод:** -1


**Пример 3**  
**Ввод:**  nums = [1], target = 0
**Вывод:** -1



---

## Ограничения
- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i] <= 10^4`
- Все значения в `nums` уникальны
- `nums` — это массив, отсортированный по возрастанию, который **возможно был повернут**
- `-10^4 <= target <= 10^4`

